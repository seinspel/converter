// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils$Converter from "./Utils.mjs";

var pureVowels = [
  "A",
  "AH",
  "AHY",
  "AW",
  "EE",
  "EH",
  "EW",
  "EY",
  "IA",
  "IH",
  "II",
  "O",
  "OA",
  "OH",
  "OO",
  "OW",
  "OY",
  "U",
  "UH",
  "ə"
];

var rVowels = [
  "AR",
  "EIR",
  "EWR",
  "IER",
  "IRE",
  "OIR",
  "OOR",
  "OR",
  "OWR",
  "UR",
  "əR"
];

var partVowels = [
  "EL",
  "EM",
  "EN"
];

function vowels(param) {
  return pureVowels.concat(rVowels, partVowels);
}

var unambiguousBeforeL = [
  "B",
  "CH",
  "D",
  "DH",
  "F",
  "G",
  "J",
  "K",
  "P",
  "S",
  "SH",
  "T",
  "TH",
  "V",
  "Z",
  "ZH"
];

var unambiguousBeforeM = [
  "B",
  "CH",
  "D",
  "DH",
  "F",
  "G",
  "J",
  "K",
  "P",
  "S",
  "SH",
  "T",
  "TH",
  "V",
  "Z",
  "ZH"
];

var unambiguousBeforeN = [
  "B",
  "CH",
  "D",
  "DH",
  "F",
  "G",
  "J",
  "K",
  "P",
  "S",
  "SH",
  "T",
  "TH",
  "V",
  "Z",
  "ZH"
];

var unambiguousBeforeR = [
  "B",
  "CH",
  "D",
  "DH",
  "F",
  "G",
  "J",
  "K",
  "L",
  "M",
  "N",
  "NG",
  "P",
  "S",
  "SH",
  "T",
  "TH",
  "V",
  "Z",
  "ZH"
];

var voicelessCons = [
  "CH",
  "F",
  "K",
  "P",
  "S",
  "SH",
  "T",
  "TH"
];

var longToShortMap = {
  'AH': 'A',
  /* 'EY': 'EH', */
  'EE': 'IH',
  'OH': 'O',
  'OO': 'U',
  'ə': 'A'
};

var shortVowels = [
  "A",
  "EH",
  "IH",
  "O",
  "OA",
  "U",
  "UH"
];

function splitOffStress(symbol) {
  var lastChar = symbol.slice(-1);
  var hasStressMarker = [
      "0",
      "1"
    ].includes(lastChar);
  if (hasStressMarker) {
    return [
            symbol.slice(0, -1),
            lastChar === "1"
          ];
  } else {
    return [
            symbol,
            false
          ];
  }
}

function isVowel(phon, endingOpt, param) {
  var ending = endingOpt !== undefined ? endingOpt : false;
  if (phon === undefined) {
    return false;
  }
  var match = splitOffStress(phon);
  var phonNoS = match[0];
  if (ending) {
    return pureVowels.includes(phonNoS);
  } else {
    return vowels(undefined).includes(phonNoS);
  }
}

function countVowels(phons) {
  return phons.reduce((function (numVowels, phon) {
                if (isVowel(phon, undefined, undefined)) {
                  return numVowels + 1 | 0;
                } else {
                  return numVowels;
                }
              }), 0);
}

function isOpenSyllable(ahead1, ahead2) {
  if (ahead1 !== undefined && !(ahead1 === "'" || isVowel(ahead1, undefined, undefined))) {
    if (ahead2 !== undefined && !(ahead2 === "'" || !isVowel(ahead2, undefined, undefined))) {
      return ![
                "EW",
                "EWR"
              ].includes(ahead2.slice(0, -1));
    } else {
      return false;
    }
  } else {
    return true;
  }
}

function maybeFst(tuple, takeFst) {
  return takeFst ? tuple[0] : tuple[1];
}

function convertSymbol(symbolNoS, behind, ahead1, stress, withMerger, reduplicate, lexicalSets, consonants) {
  var maybeRedub = function (letters) {
    if (reduplicate) {
      return letters[0] + letters;
    } else {
      return letters;
    }
  };
  switch (symbolNoS) {
    case "A" :
        return maybeFst(lexicalSets.trap, stress);
    case "AH" :
        return maybeFst(lexicalSets.palm, stress);
    case "AHY" :
        return maybeFst(lexicalSets.price, stress);
    case "AR" :
        return maybeFst(lexicalSets.start, stress);
    case "AW" :
        if (withMerger && ahead1 !== "RR") {
          return maybeFst(lexicalSets.palm, stress);
        } else {
          return maybeFst(lexicalSets.thought, stress);
        }
    case "B" :
        return maybeRedub(consonants.b);
    case "CH" :
        return maybeRedub(consonants.ch);
    case "D" :
        return maybeRedub(consonants.d);
    case "DH" :
        return maybeRedub(consonants.dh);
    case "EE" :
        return maybeFst(lexicalSets.fleece, stress);
    case "EH" :
        return maybeFst(lexicalSets.dress, stress);
    case "EIR" :
        return maybeFst(lexicalSets.square, stress);
    case "EL" :
        if (ahead1 === undefined && behind !== undefined && unambiguousBeforeL.includes(behind)) {
          return consonants.el;
        }
        return lexicalSets.comma + consonants.l;
    case "EM" :
        if (ahead1 === undefined && behind !== undefined && unambiguousBeforeM.includes(behind)) {
          return consonants.em;
        }
        return lexicalSets.comma + consonants.m;
    case "EN" :
        var exit = 0;
        var behind$1;
        if (ahead1 !== undefined) {
          if (ahead1 === "'" && behind !== undefined) {
            behind$1 = behind;
            exit = 2;
          }
          
        } else if (behind !== undefined) {
          behind$1 = behind;
          exit = 2;
        }
        if (exit === 2 && unambiguousBeforeN.includes(behind$1)) {
          return consonants.en;
        }
        return lexicalSets.comma + consonants.n;
    case "EW" :
        return maybeFst(lexicalSets.cute, stress);
    case "EWR" :
        return maybeFst(lexicalSets.cure, stress);
    case "EY" :
        return maybeFst(lexicalSets.face, stress);
    case "F" :
        return maybeRedub(consonants.f);
    case "G" :
        return maybeRedub(consonants.g);
    case "H" :
        return maybeRedub(consonants.hh);
    case "IA" :
        return maybeFst(lexicalSets.ian, stress);
    case "IER" :
        return maybeFst(lexicalSets.near, stress);
    case "IH" :
        return maybeFst(lexicalSets.kit, stress);
    case "II" :
        return lexicalSets.happy;
    case "IRE" :
        return maybeFst(lexicalSets.fire, stress);
    case "J" :
        return maybeRedub(consonants.j);
    case "K" :
        return maybeRedub(consonants.k);
    case "L" :
        return maybeRedub(consonants.l);
    case "M" :
        return maybeRedub(consonants.m);
    case "N" :
        return maybeRedub(consonants.n);
    case "NG" :
        if (ahead1 === undefined) {
          return consonants.ng;
        }
        switch (ahead1) {
          case "G" :
          case "K" :
              return consonants.n;
          default:
            return consonants.ng;
        }
    case "O" :
        if (withMerger) {
          if (ahead1 === "RR") {
            return maybeFst(lexicalSets.thought, stress);
          } else {
            return maybeFst(lexicalSets.palm, stress);
          }
        } else {
          return maybeFst(lexicalSets.lot, stress);
        }
    case "OA" :
        return maybeFst(lexicalSets.cloth, stress);
    case "OH" :
        return maybeFst(lexicalSets.goat, stress);
    case "OHR" :
        return maybeFst(lexicalSets.force, stress);
    case "OIR" :
        return maybeFst(lexicalSets.coir, stress);
    case "OO" :
        return maybeFst(lexicalSets.goose, stress);
    case "OOR" :
        return maybeFst(lexicalSets.poor, stress);
    case "OR" :
        return maybeFst(lexicalSets.north, stress);
    case "OW" :
        return maybeFst(lexicalSets.mouth, stress);
    case "OWR" :
        return maybeFst(lexicalSets.flour, stress);
    case "OY" :
        return maybeFst(lexicalSets.choice, stress);
    case "P" :
        return maybeRedub(consonants.p);
    case "RR" :
        if (behind !== undefined && isVowel(behind, true, undefined)) {
          return consonants.vrv;
        } else {
          return consonants.crv;
        }
    case "S" :
        var postVocalic = isVowel(behind, true, undefined);
        if (behind !== undefined && ahead1 === undefined && !voicelessCons.includes(behind)) {
          return consonants.vs;
        }
        if (postVocalic && isVowel(ahead1, undefined, undefined)) {
          return consonants.vs;
        } else {
          return consonants.cs;
        }
    case "SH" :
        return maybeRedub(consonants.sh);
    case "T" :
        return maybeRedub(consonants.t);
    case "TH" :
        return maybeRedub(consonants.th);
    case "U" :
        return maybeFst(lexicalSets.foot, stress);
    case "UH" :
        return maybeFst(lexicalSets.strut, stress);
    case "UR" :
        return maybeFst(lexicalSets.nurse, stress);
    case "V" :
        return maybeRedub(consonants.v);
    case "W" :
        return maybeRedub(consonants.w);
    case "WH" :
        return maybeRedub(consonants.wh);
    case "Y" :
        return maybeRedub(consonants.y);
    case "Z" :
        var postVocalic$1 = isVowel(behind, true, undefined);
        if (!postVocalic$1 && isVowel(ahead1, undefined, undefined) || ahead1 !== undefined && postVocalic$1 && !isVowel(ahead1, undefined, undefined)) {
          return consonants.zv;
        } else {
          return consonants.zc;
        }
    case "ZH" :
        return maybeRedub(consonants.zh);
    default:
      if (symbolNoS === "ə") {
        return lexicalSets.comma;
      } else if (symbolNoS === "əR") {
        if (ahead1 !== undefined || !(behind !== undefined && unambiguousBeforeR.includes(behind))) {
          return lexicalSets.letter;
        } else {
          return consonants.er;
        }
      } else {
        return ;
      }
  }
}

function assemble(phons, settings) {
  var numSyllables = countVowels(phons);
  var withStress = settings.withStress && numSyllables >= 2;
  var phons$1 = settings.longToShort ? phons.reduce((function (newPhons, symbol) {
            if (symbol.slice(0, -1) === "IA") {
              newPhons.push("IH" + symbol.slice(-1));
              newPhons.push("ə");
            } else {
              newPhons.push(symbol);
            }
            return newPhons;
          }), []) : phons;
  return phons$1.reduce((function (state, symbol, i) {
                var ahead1 = Utils$Converter.safeGet(phons$1, i + 1 | 0);
                var ahead2 = Utils$Converter.safeGet(phons$1, i + 2 | 0);
                var behind1 = Utils$Converter.safeGet(phons$1, i - 1 | 0);
                var behind = behind1 === "'" ? Utils$Converter.safeGet(phons$1, i - 2 | 0) : behind1;
                var reduplicate = state.reduplicateNext;
                var reduplicateNext = false;
                var match = splitOffStress(symbol);
                var symbolNoS = match[0];
                var stress = withStress && match[1];
                var match$1;
                if (settings.longToShort && isOpenSyllable(ahead1, ahead2)) {
                  var newSymbol = Utils$Converter.safeGetD(longToShortMap, symbolNoS);
                  if (newSymbol) {
                    match$1 = [
                      newSymbol._0,
                      isVowel(ahead1, undefined, undefined) ? "'" : ""
                    ];
                  } else {
                    if (shortVowels.includes(symbolNoS)) {
                      reduplicateNext = true;
                    }
                    match$1 = [
                      symbolNoS,
                      ""
                    ];
                  }
                } else {
                  match$1 = [
                    symbolNoS,
                    ""
                  ];
                }
                var newLetters = convertSymbol(match$1[0], behind, ahead1, stress, settings.withMerger, reduplicate, settings.lexicalSets, settings.consonants);
                var newLetters$1 = Utils$Converter.unwrapS(newLetters, symbol);
                var lastOld = Utils$Converter.safeGetS(state.result.slice(-1), 0);
                var firstNew = Utils$Converter.safeGetS(newLetters$1, 0);
                var separator = lastOld !== undefined && firstNew !== undefined ? (
                    "aeiouyáéíóúýāēīōū".includes(lastOld) && lastOld === firstNew || (lastOld === "c" || lastOld === "s") && firstNew === "h" ? "'" : (
                        lastOld === "d" && firstNew === "j" ? "h" : ""
                      )
                  ) : "";
                var result = state.result + separator + newLetters$1 + match$1[1];
                return {
                        result: result,
                        reduplicateNext: reduplicateNext
                      };
              }), {
              result: "",
              reduplicateNext: false
            }).result;
}

export {
  assemble ,
  
}
/* No side effect */
