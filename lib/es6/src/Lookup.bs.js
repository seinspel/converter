// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as Utils$Converter from "./Utils.bs.js";
import * as Assemble$Converter from "./Assemble.bs.js";
import * as Constants$Converter from "./Constants.bs.js";
import * as Controller$Converter from "./Controller.bs.js";
import * as AsciiDecompression$Converter from "./AsciiDecompression.bs.js";

var dict = {
  contents: {}
};

function loadDict(req) {
  try {
    var parsed = JSON.parse(req.responseText);
    var value = Utils$Converter.classifyJson(parsed);
    if (typeof value === "number" || value.TAG !== /* JSONObject */2) {
      return ;
    } else {
      dict.contents = value._0;
      return ;
    }
  }
  catch (exn){
    console.log("Parsing of dictionary failed.");
    return ;
  }
}

function convertToString(t) {
  var value = Utils$Converter.safeCastToString(t);
  if (value !== undefined) {
    return value;
  } else {
    return "";
  }
}

var convertToStringU = convertToString;

function lookup(s) {
  var result = Utils$Converter.safeGetD(dict.contents, s.toUpperCase());
  if (!result) {
    return ;
  }
  var value = Utils$Converter.classifyJson(result._0);
  if (typeof value === "number") {
    return ;
  }
  switch (value.TAG | 0) {
    case /* JSONString */0 :
        return {
                TAG: /* Single */0,
                _0: value._0
              };
    case /* JSONObject */2 :
        return {
                TAG: /* Variants */2,
                _0: Utils$Converter.mapD(value._0, convertToStringU)
              };
    case /* JSONArray */3 :
        return {
                TAG: /* Multiple */1,
                _0: value._0.map(convertToString)
              };
    default:
      return ;
  }
}

function decodePhonemes(letters) {
  return Array.from(letters, (function (x) {
                return AsciiDecompression$Converter.asciiDecompression[x];
              }));
}

function addSuffix(lookupResults, suffix, identifiers) {
  if (lookupResults === undefined) {
    return ;
  }
  switch (lookupResults.TAG | 0) {
    case /* Single */0 :
        return [lookupResults._0 + suffix];
    case /* Multiple */1 :
        return lookupResults._0.map(function (x) {
                    return x + suffix;
                  });
    case /* Variants */2 :
        return Object.entries(lookupResults._0).filter(function (param) {
                      return identifiers.includes(param[0]);
                    }).map(function (param) {
                    return param[1] + suffix;
                  });
    
  }
}

function findBaseForm(chunk) {
  var chunkUpper = chunk.toUpperCase();
  var chunkLast1 = chunkUpper.slice(-1);
  var chunkLast2 = chunkUpper.slice(-2);
  var chunkLast3 = chunkUpper.slice(-3);
  if (chunkLast3 === "ING") {
    var x = lookup(chunk.slice(0, -3));
    var result = x !== undefined ? x : lookup(chunk.slice(0, -3) + "E");
    return addSuffix(result, "=m", ["v"]);
  }
  if (chunkLast1 === "S") {
    var resultSS = chunkLast3 === "S'S" ? addSuffix(lookup(chunk.slice(0, -3)), "x'x", ["n"]) : undefined;
    if (resultSS !== undefined) {
      return resultSS;
    }
    var resultPosessive = chunkLast2 === "'S" ? addSuffix(lookup(chunk.slice(0, -2)), "'x", ["n"]) : undefined;
    if (resultPosessive !== undefined) {
      return resultPosessive;
    } else {
      return addSuffix(lookup(chunk.slice(0, -1)), "x", [
                  "n",
                  "v"
                ]);
    }
  }
  switch (chunkLast2) {
    case "ED" :
        var x$1 = lookup(chunk.slice(0, -2));
        var result$1 = x$1 !== undefined ? x$1 : lookup(chunk.slice(0, -1));
        return addSuffix(result$1, "c", ["v"]);
    case "LY" :
        var resultLLY = chunkLast3 === "LLY" ? addSuffix(lookup(chunk.slice(0, -3)), "}", ["j"]) : undefined;
        if (resultLLY !== undefined) {
          return resultLLY;
        } else {
          return addSuffix(lookup(chunk.slice(0, -2)), "j}", ["j"]);
        }
    default:
      return ;
  }
}

function convertToSpelling(chunk, lookupResults, settings) {
  var allConverted = lookupResults.map(function (variant) {
        var phons = decodePhonemes(variant);
        var converted = Assemble$Converter.assemble(phons, settings);
        if (chunk === "I") {
          return converted;
        } else if (chunk.toUpperCase() === chunk && chunk.toUpperCase() !== "A") {
          return converted.toUpperCase();
        } else if (chunk[0] === "'" || chunk[0].toUpperCase() !== chunk[0]) {
          return converted;
        } else {
          return converted[0].toUpperCase() + converted.slice(1);
        }
      });
  if (allConverted.length === 1) {
    return allConverted[0];
  } else {
    return "(" + allConverted.join("/") + ")";
  }
}

function convertText(text, settings) {
  var chunks = text.replace(/â€™/gi, "'").split(/([^a-zA-Z'])/);
  console.log(chunks);
  return chunks.reduce((function (result, maybeChunk) {
                if (maybeChunk === undefined) {
                  return result;
                }
                if (!/[a-zA-Z]/.test(maybeChunk)) {
                  return result + maybeChunk;
                }
                var lookupResults = lookup(maybeChunk);
                if (lookupResults !== undefined) {
                  var words;
                  switch (lookupResults.TAG | 0) {
                    case /* Single */0 :
                        words = [lookupResults._0];
                        break;
                    case /* Multiple */1 :
                        words = lookupResults._0;
                        break;
                    case /* Variants */2 :
                        words = Object.values(lookupResults._0);
                        break;
                    
                  }
                  return result + convertToSpelling(maybeChunk, words, settings);
                }
                var lookupResults$1 = findBaseForm(maybeChunk);
                if (lookupResults$1 !== undefined) {
                  return result + convertToSpelling(maybeChunk, lookupResults$1, settings);
                } else {
                  return result + "<" + maybeChunk + ">";
                }
              }), "");
}

function processText(param) {
  var text = document.getElementById("input").value;
  var withMerger = document.getElementById("withMerger").checked;
  var withStress = document.getElementById("withStress").checked;
  var withMacrons = document.getElementById("withMacrons").checked;
  var longToShort = document.getElementById("longToShort").checked;
  if (withMacrons) {
    Constants$Converter.setSpelling(Constants$Converter.lexicalsetsMacron, Constants$Converter.consonantsMacron);
  } else if (withStress) {
    Constants$Converter.setSpelling(Constants$Converter.lexicalSetsEuropean, Constants$Converter.consonantsEuropean);
  } else {
    var match = Controller$Converter.loadSpelling(undefined);
    Constants$Converter.setSpelling(match[0], match[1]);
  }
  var result = convertText(text, {
        withStress: withStress,
        withMerger: withMerger,
        longToShort: longToShort
      });
  var output = document.getElementById("output");
  output.value = result;
  
}

function tests(param) {
  var inputField = document.getElementById("input");
  inputField.value = "Foreskin SEEING dying saying behalf suing teriyaki\nevacuate boyhood adhere bloodshed midyear knowing away short awestruck withhold\nadulthood malevolent criminal fewer lure neurology careless what\'s think\nnighttime Mary merry marry mirror nearer hurry furry horror lore";
  
}

Constants$Converter.setSpelling(Constants$Converter.lexicalSetsEuropean, Constants$Converter.consonantsEuropean);

console.log(convertText("First second reading.", {
          withStress: false,
          withMerger: false,
          longToShort: true
        }));

export {
  loadDict ,
  processText ,
  tests ,
  
}
/*  Not a pure module */
